<!DOCTYPE html>
<!--
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  FABRIZIOSALMI - INTERACTIVE CYBERPUNK PORTFOLIO            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üé® VISUAL EFFECTS:
  ‚úì WebGL Fragment Shaders - Cyberpunk distortion, scanlines, noise, grid
  ‚úì Advanced Particle System - 500+ particles with physics, flow fields, object pooling
  ‚úì Audio-Reactive Visualizer - FFT analysis, 64-bar circular spectrum, beat sync
  ‚úì Gesture Recognition - Multi-touch, pattern detection, particle trails
  ‚úì Magnetic Cursor - Smooth attraction to interactive elements
  ‚úì Parallax Scrolling - Multi-layer depth effect
  ‚úì Ambient Effects - Aurora flows, meteor showers, orbital glows
  ‚úì Ripple Waves - Click-triggered expanding rings

üéµ AUDIO:
  ‚úì Generative DnB Beat - 174 BPM drum & bass with kick, snare, hi-hats, bass
  ‚úì Delay/Reverb FX - Spatial audio processing
  ‚úì Glitch Effects - Random glitch sounds
  ‚úì Web Audio API - Real-time synthesis

üéÆ INTERACTIONS:
  ‚úì Magnetic Cursor - Drawn to buttons/links (50px radius)
  ‚úì Click Drawing - Draw on canvas, trigger particle effects
  ‚úì Scroll Progress Bar - Gradient indicator
  ‚úì Easter Eggs:
    ‚Ä¢ Konami Code (‚Üë‚Üë‚Üì‚Üì‚Üê‚Üí‚Üê‚ÜíBA) ‚Üí Matrix rain
    ‚Ä¢ Triple Click ‚Üí Color inversion (2s)

‚ö° PERFORMANCE:
  ‚úì Lazy Loading - All heavy effects load after interaction
  ‚úì Object Pooling - Particle recycling (no GC pressure)
  ‚úì RAF Throttling - WebGL @ 30fps, adaptive frame skipping
  ‚úì Device Detection - Mobile gets lighter effects
  ‚úì Auto-Disable - Effects turn off if FPS < 30
  ‚úì Debounced Resize - 250ms timeout on window resize
  ‚úì Passive Event Listeners - Scroll/touch optimization
  ‚úì Desynchronized Canvas - Off-thread rendering where supported
  ‚úì Critical CSS Inline - Instant render
  ‚úì Intersection Observer - Lazy data loading

üì± RESPONSIVE:
  ‚úì Mobile-optimized - Reduced particle count & effects
  ‚úì Touch gestures - Full multi-touch support
  ‚úì Adaptive quality - Based on hardware cores

üéØ TARGET AUDIENCE IMPACT:
  ‚Ä¢ Nerds ‚Üí WebGL shaders, particle physics, audio synthesis, clean code
  ‚Ä¢ VCs ‚Üí Performance metrics, scalable architecture, modern tech stack
  ‚Ä¢ Artists ‚Üí Aesthetic cyberpunk design, audio-reactive visuals, creative coding

Built with: Vanilla JS, WebGL, Web Audio API, Canvas 2D
No frameworks, no libraries, pure performance.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fabriziosalmi - code & sound</title>
    <meta name="description" content="Developer, sound designer, creative coder. Building the future with code and beats.">
    <meta name="referrer" content="no-referrer">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="fabriziosalmi - code & sound">
    <meta property="og:description" content="Interactive cyberpunk portfolio with WebGL shaders, audio-reactive visuals, and advanced particle systems.">
    <meta property="og:image" content="https://github.com/fabriziosalmi.png">
    <meta property="og:url" content="https://fabriziosalmi.github.io">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="fabriziosalmi - code & sound">
    <meta name="twitter:description" content="Interactive cyberpunk portfolio with cutting-edge web technologies">
    <meta name="twitter:image" content="https://github.com/fabriziosalmi.png">

    <!-- Theme & PWA -->
    <meta name="theme-color" content="#0a0a0f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Critical Resource Hints -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://github.com">
    <link rel="preload" as="image" href="https://github.com/fabriziosalmi.png">
    <link rel="icon" href="https://github.com/fabriziosalmi.png" crossorigin="anonymous">
    
    <!-- Critical CSS Inline (Above-the-fold only) -->
    <style>
        *{margin:0;padding:0;box-sizing:border-box}:root{--neon-cyan:#00ffff;--neon-magenta:#ff00ff;--neon-yellow:#ff0;--deep-space:#0a0a0f;--cosmic-purple:#1a0a2e;--electric-blue:#06f;--plasma-pink:#ff0080}html{scroll-behavior:smooth;cursor:none}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:radial-gradient(ellipse at top,var(--cosmic-purple),var(--deep-space));color:#fff;overflow-x:hidden;min-height:100vh;position:relative}.cursor{width:20px;height:20px;border:2px solid var(--neon-cyan);border-radius:50%;position:fixed;pointer-events:none;z-index:9999;transition:all .1s ease;mix-blend-mode:difference;transform:translateZ(0)}.stars{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0;transform:translateZ(0)}.star{position:absolute;width:2px;height:2px;background:#fff;border-radius:50%;animation:twinkle 3s infinite}@keyframes twinkle{0%,100%{opacity:.3}50%{opacity:1}}nav{position:fixed;top:0;left:0;right:0;padding:1.5rem 5%;background:rgba(10,10,15,.8);backdrop-filter:blur(20px);border-bottom:1px solid rgba(0,255,255,.1);z-index:1000;display:flex;justify-content:space-between;align-items:center}.logo{font-size:1.5rem;font-weight:900;background:linear-gradient(135deg,var(--neon-cyan),var(--neon-magenta));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:-1px}.nav-links{display:flex;gap:2rem;list-style:none}.nav-links a{color:#fff;text-decoration:none;font-weight:500;transition:all .3s;position:relative}.audio-toggle{background:0 0;border:2px solid var(--neon-cyan);color:var(--neon-cyan);width:40px;height:40px;border-radius:50%;cursor:pointer;transition:all .3s;display:flex;align-items:center;justify-content:center}.hero{min-height:100vh;display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:8rem 5% 4rem;position:relative;z-index:1}.avatar{width:200px;height:200px;border-radius:50%;border:4px solid transparent;background:linear-gradient(var(--deep-space),var(--deep-space)) padding-box,linear-gradient(135deg,var(--neon-cyan),var(--neon-magenta)) border-box;margin-bottom:2rem;animation:float 6s ease-in-out infinite;box-shadow:0 0 60px rgba(0,255,255,.3);transition:all .5s}@keyframes float{0%,100%{transform:translateY(0)}50%{transform:translateY(-20px)}}h1{font-size:clamp(3rem,8vw,7rem);font-weight:900;margin-bottom:1rem;background:linear-gradient(135deg,var(--neon-cyan),var(--neon-magenta),var(--neon-yellow));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;animation:glow 3s ease-in-out infinite}@keyframes glow{0%,100%{filter:drop-shadow(0 0 20px rgba(0,255,255,.5))}50%{filter:drop-shadow(0 0 40px rgba(255,0,255,.7))}}.tagline{font-size:clamp(1.2rem,3vw,2rem);color:rgba(255,255,255,.7);margin-bottom:3rem;font-weight:300}.cta-buttons{display:flex;gap:1.5rem;flex-wrap:wrap;justify-content:center}.btn{padding:1rem 2.5rem;border-radius:50px;font-weight:600;text-decoration:none;display:inline-flex;align-items:center;gap:.5rem;transition:all .3s;border:2px solid transparent;cursor:pointer}.btn-primary{background:linear-gradient(135deg,var(--neon-cyan),var(--electric-blue));color:var(--deep-space)}.btn-outline{border-color:var(--neon-magenta);color:var(--neon-magenta)}.scroll-indicator{position:absolute;bottom:2rem;left:50%;transform:translateX(-50%);animation:bounce 2s infinite}@keyframes bounce{0%,100%{transform:translateX(-50%) translateY(0)}50%{transform:translateX(-50%) translateY(10px)}}@media(max-width:768px){nav{flex-direction:column;gap:1rem}.nav-links{flex-direction:column;gap:1rem;text-align:center}}
    </style>
    
    <!-- Deferred CSS (below-the-fold) -->
    <link rel="preload" as="style" href="data:text/css;base64,LyogQmVsb3cgdGhlIGZvbGQgc3R5bGVzIC0gbG9hZCBhc3luYyAqLw==" onload="this.onload=null;this.rel='stylesheet'">
</head>
<body>
    <!-- WebGL Canvas for Advanced Effects -->
    <canvas id="webglCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0;opacity:0;transition:opacity 2s"></canvas>

    <!-- Audio Visualizer Canvas -->
    <canvas id="audioViz" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;opacity:0;transition:opacity 1s;mix-blend-mode:screen"></canvas>

    <!-- Particle Canvas -->
    <canvas id="particleCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0;opacity:0;transition:opacity 1.5s"></canvas>

    <!-- Custom Cursor -->
    <div class="cursor" id="cursor"></div>

    <!-- Stars Background -->
    <div class="stars" id="stars"></div>

    <!-- Gesture Canvas (interactive) -->
    <canvas id="gestureCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:5;opacity:0;transition:opacity .5s"></canvas>

    <!-- Navigation -->
    <nav>
        <div class="logo">fabriziosalmi</div>
        <ul class="nav-links">
            <li><a href="#home">Home</a></li>
            <li><a href="#stats">Stats</a></li>
            <li><a href="#repos">Projects</a></li>
            <li><a href="https://github.com/fabriziosalmi" target="_blank" rel="noopener">GitHub</a></li>
        </ul>
        <button class="audio-toggle" id="audioToggle" title="Toggle Audio" aria-label="Toggle Audio">
            <span id="audioIcon">üîä</span>
        </button>
    </nav>

    <!-- Hero Section -->
    <section class="hero" id="home">
        <img src="https://github.com/fabriziosalmi.png" alt="fabriziosalmi" class="avatar" loading="eager" fetchpriority="high">
        <h1>fabriziosalmi</h1>
        <p class="tagline">code, sound, creativity</p>
        <div class="cta-buttons">
            <a href="https://github.com/fabriziosalmi" target="_blank" rel="noopener" class="btn btn-primary">View GitHub</a>
            <a href="#repos" class="btn btn-outline">Explore Projects</a>
        </div>
        <div class="scroll-indicator">‚Üì</div>
    </section>

    <!-- Stats Section (lazy loaded) -->
    <section class="stats-section" id="stats">
        <h2 class="section-title">GitHub Statistics</h2>
        <div class="stats-grid" id="statsGrid"></div>
    </section>

    <!-- Repositories Section (lazy loaded) -->
    <section class="repos-section" id="repos">
        <h2 class="section-title">Featured Projects</h2>
        <div class="repos-grid" id="reposGrid"></div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="footer-links">
            <a href="https://github.com/fabriziosalmi" target="_blank" rel="noopener" aria-label="GitHub">GH</a>
            <a href="https://twitter.com/fabriziosalmi" target="_blank" rel="noopener" aria-label="Twitter">TW</a>
            <a href="mailto:fabrizio.salmi@gmail.com" aria-label="Email">‚úâÔ∏è</a>
        </div>
        <p>¬© 2025 fabriziosalmi</p>
    </footer>

    <!-- Deferred styles -->
    <style media="print" onload="this.media='all'">
        .cursor-trail{width:6px;height:6px;background:var(--neon-cyan);border-radius:50%;position:fixed;pointer-events:none;z-index:9998;opacity:.6}.nav-links a:hover{color:var(--neon-cyan)}.nav-links a::after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:var(--neon-cyan);transition:width .3s}.nav-links a:hover::after{width:100%}.audio-toggle:hover{background:var(--neon-cyan);color:var(--deep-space);box-shadow:0 0 20px var(--neon-cyan)}.avatar:hover{transform:scale(1.1) rotate(5deg);box-shadow:0 0 80px rgba(255,0,255,.5)}.btn-primary:hover{transform:translateY(-3px);box-shadow:0 10px 30px rgba(0,255,255,.4)}.btn-outline:hover{background:var(--neon-magenta);color:var(--deep-space);box-shadow:0 10px 30px rgba(255,0,255,.4)}.section-title{text-align:center;font-size:clamp(2.5rem,5vw,4rem);margin-bottom:4rem;background:linear-gradient(135deg,#fff,var(--neon-cyan));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}.stats-section{padding:6rem 5%;position:relative;z-index:1}.stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:2rem;max-width:1400px;margin:0 auto}.stat-card{background:rgba(255,255,255,.03);backdrop-filter:blur(20px);border:1px solid rgba(255,255,255,.1);border-radius:20px;padding:2rem;text-align:center;transition:all .3s;position:relative;overflow:hidden;will-change:transform}.stat-card::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,var(--neon-cyan),var(--neon-magenta));opacity:0;transition:opacity .3s}.stat-card:hover::before{opacity:.1}.stat-card:hover{transform:translateY(-10px);border-color:var(--neon-cyan);box-shadow:0 20px 40px rgba(0,255,255,.2)}.stat-icon{font-size:3rem;margin-bottom:1rem;background:linear-gradient(135deg,var(--neon-cyan),var(--neon-magenta));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}.stat-value{font-size:2.5rem;font-weight:900;margin-bottom:.5rem;color:var(--neon-cyan)}.stat-label{color:rgba(255,255,255,.6);font-size:.9rem;text-transform:uppercase;letter-spacing:1px}.repos-section{padding:6rem 5%;background:linear-gradient(180deg,transparent,rgba(0,255,255,.02));position:relative;z-index:1}.repos-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(350px,1fr));gap:2rem;max-width:1400px;margin:0 auto}.repo-card{background:rgba(255,255,255,.03);backdrop-filter:blur(20px);border:1px solid rgba(255,255,255,.1);border-radius:20px;padding:2rem;transition:all .3s;position:relative;overflow:hidden;will-change:transform}.repo-card::before{content:'';position:absolute;top:0;left:0;width:4px;height:100%;background:linear-gradient(180deg,var(--neon-cyan),var(--neon-magenta));transform:scaleY(0);transition:transform .3s}.repo-card:hover::before{transform:scaleY(1)}.repo-card:hover{transform:translateX(10px);border-color:var(--neon-cyan);box-shadow:0 10px 30px rgba(0,255,255,.2)}.repo-name{font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:var(--neon-cyan)}.repo-desc{color:rgba(255,255,255,.7);margin-bottom:1.5rem;line-height:1.6}.repo-stats{display:flex;gap:1.5rem;flex-wrap:wrap;margin-bottom:1rem}.repo-stat{display:flex;align-items:center;gap:.5rem;color:rgba(255,255,255,.5);font-size:.9rem}footer{padding:4rem 5%;text-align:center;border-top:1px solid rgba(255,255,255,.1);position:relative;z-index:1}.footer-links{display:flex;justify-content:center;gap:2rem;margin-bottom:2rem}.footer-links a{color:rgba(255,255,255,.6);text-decoration:none;font-size:1.5rem;transition:all .3s}.footer-links a:hover{color:var(--neon-cyan);transform:translateY(-3px)}.ambient-orb{position:fixed;border-radius:50%;pointer-events:none;z-index:0;filter:blur(80px);opacity:0;transition:opacity 2s ease;transform:translateZ(0)}.ambient-orb.active{opacity:.15}.aurora{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0;opacity:0;background:linear-gradient(45deg,transparent 0%,rgba(0,255,255,.05) 25%,transparent 50%,rgba(255,0,255,.05) 75%,transparent 100%);background-size:200% 200%;animation:aurora-flow 20s ease infinite;transition:opacity 3s ease;transform:translateZ(0)}.aurora.active{opacity:1}@keyframes aurora-flow{0%,100%{background-position:0 0}50%{background-position:100% 100%}}.meteor{position:fixed;width:2px;height:80px;background:linear-gradient(to bottom,rgba(255,255,255,0),rgba(0,255,255,.8));border-radius:50%;pointer-events:none;z-index:1;animation:meteor-fall 2s linear}@keyframes meteor-fall{0%{opacity:1;transform:translateY(0) translateX(0) rotate(45deg)}100%{opacity:0;transform:translateY(100vh) translateX(50vw) rotate(45deg)}}.pulse-ring{position:fixed;border:2px solid var(--neon-cyan);border-radius:50%;pointer-events:none;z-index:0;opacity:0;animation:pulse-expand 3s ease-out}@keyframes pulse-expand{0%{width:50px;height:50px;opacity:.8}100%{width:400px;height:400px;opacity:0}}@media(prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:.01ms!important;animation-iteration-count:1!important;transition-duration:.01ms!important}}@media(max-width:768px){.stats-grid,.repos-grid{grid-template-columns:1fr}.cta-buttons{flex-direction:column}}
    </style>

    <!-- Minimal optimized JavaScript -->
    <script>
        // Advanced Cursor (magnetic effect + enhanced trails)
        (()=>{
            const c=document.getElementById('cursor');
            let mX=0,mY=0,cX=0,cY=0,tc=0;
            let magnetTarget = null;
            const magneticElements = [];

            // Register magnetic elements (buttons, links, cards)
            const registerMagnetic = () => {
                document.querySelectorAll('.btn, .nav-links a, .stat-card, .repo-card, .avatar').forEach(el => {
                    magneticElements.push({
                        el,
                        rect: el.getBoundingClientRect(),
                        strength: el.classList.contains('btn') ? 50 : 30
                    });
                });
            };

            setTimeout(registerMagnetic, 1000);
            window.addEventListener('resize', registerMagnetic, {passive: true});

            document.addEventListener('mousemove',e=>{
                mX=e.clientX;
                mY=e.clientY;

                // Check magnetic attraction
                magnetTarget = null;
                for(const mag of magneticElements) {
                    const rect = mag.el.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.sqrt(Math.pow(mX - cx, 2) + Math.pow(mY - cy, 2));
                    if(dist < mag.strength) {
                        magnetTarget = {x: cx, y: cy, strength: mag.strength - dist};
                        break;
                    }
                }
            },{passive:true});

            const aC=()=>{
                let targetX = mX;
                let targetY = mY;

                // Apply magnetic effect
                if(magnetTarget) {
                    const force = magnetTarget.strength / 50;
                    targetX += (magnetTarget.x - mX) * force * 0.3;
                    targetY += (magnetTarget.y - mY) * force * 0.3;
                }

                cX+=(targetX-cX)*.2;
                cY+=(targetY-cY)*.2;
                c.style.cssText=`left:${cX}px;top:${cY}px${magnetTarget ? ';transform:scale(1.5);border-color:#ff00ff' : ''}`;

                tc++;
                if(tc>5&&Math.random()>.92){
                    const t=document.createElement('div');
                    t.className='cursor-trail';
                    t.style.cssText=`left:${cX}px;top:${cY}px`;
                    document.body.appendChild(t);
                    setTimeout(()=>t.remove(),500);
                    tc=0;
                }
                requestAnimationFrame(aC);
            };
            aC();

            // Easter egg: Konami code
            let konamiIndex = 0;
            const konamiCode = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
            document.addEventListener('keydown', e => {
                if(e.keyCode === konamiCode[konamiIndex]) {
                    konamiIndex++;
                    if(konamiIndex === konamiCode.length) {
                        konamiIndex = 0;
                        // Matrix rain effect
                        const canvas = document.createElement('canvas');
                        canvas.id = 'matrixCanvas';
                        canvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;opacity:0;transition:opacity 1s';
                        document.body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;

                        const chars = '01';
                        const fontSize = 14;
                        const columns = canvas.width / fontSize;
                        const drops = Array(Math.floor(columns)).fill(1);

                        canvas.style.opacity = '0.8';

                        let frameCount = 0;
                        const maxFrames = 300; // 5 seconds at 60fps

                        const draw = () => {
                            if(frameCount++ > maxFrames) {
                                canvas.style.opacity = '0';
                                setTimeout(() => canvas.remove(), 1000);
                                return;
                            }

                            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            ctx.fillStyle = '#0f0';
                            ctx.font = fontSize + 'px monospace';

                            for(let i = 0; i < drops.length; i++) {
                                const text = chars[Math.floor(Math.random() * chars.length)];
                                ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                    drops[i] = 0;
                                }
                                drops[i]++;
                            }

                            requestAnimationFrame(draw);
                        };
                        draw();
                    }
                } else {
                    konamiIndex = 0;
                }
            });

            // Double-click easter egg: Color inversion
            let clickCount = 0;
            let clickTimer = null;
            document.addEventListener('click', e => {
                clickCount++;
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => clickCount = 0, 500);

                if(clickCount === 3) {
                    clickCount = 0;
                    document.body.style.filter = document.body.style.filter === 'invert(1)' ? '' : 'invert(1)';
                    setTimeout(() => document.body.style.filter = '', 2000);
                }
            });
        })();

        // Stars (optimized)
        (()=>{const s=document.getElementById('stars');const c=innerWidth<768?100:150;for(let i=0;i<c;i++){const st=document.createElement('div');st.className='star';st.style.cssText=`left:${Math.random()*100}%;top:${Math.random()*100}%;animation-delay:${Math.random()*3}s`;s.appendChild(st)}})();

        // Lazy load data
        const lD=()=>{fetch('repositories-data.json').then(r=>r.json()).then(d=>{const tS=d.reduce((s,r)=>s+r.stars,0);const tF=d.reduce((s,r)=>s+r.forks,0);const tC=d.reduce((s,r)=>s+r.commits,0);document.getElementById('statsGrid').innerHTML=`<div class="stat-card"><div class="stat-icon">üìÅ</div><div class="stat-value">${d.length}</div><div class="stat-label">Repositories</div></div><div class="stat-card"><div class="stat-icon">‚≠ê</div><div class="stat-value">${tS}</div><div class="stat-label">Total Stars</div></div><div class="stat-card"><div class="stat-icon">üî±</div><div class="stat-value">${tF}</div><div class="stat-label">Total Forks</div></div><div class="stat-card"><div class="stat-icon">üîß</div><div class="stat-value">${tC.toLocaleString()}</div><div class="stat-label">Total Commits</div></div>`;const tR=d.sort((a,b)=>b.stars-a.stars).slice(0,12);document.getElementById('reposGrid').innerHTML=tR.map(r=>`<div class="repo-card"><h3 class="repo-name">${r.name}</h3><p class="repo-desc">${r.description}</p><div class="repo-stats"><span class="repo-stat">‚≠ê ${r.stars}</span><span class="repo-stat">üî± ${r.forks}</span><span class="repo-stat">üîß ${r.commits}</span></div><a href="${r.url}" target="_blank" rel="noopener" class="btn btn-outline" style="width:100%;justify-content:center;margin-top:1rem">View Project</a></div>`).join('')}).catch(e=>console.error('Load error:',e))};

        // Lazy load audio (on demand)
        let aL=false;const iA=()=>{if(aL)return;aL=true;const s=document.createElement('script');s.textContent=`const AC=window.AudioContext||window.webkitAudioContext;let aC=null,iS=true,iM=true,mG=null,muG=null,dL=null,vC=null,dD=null,gI=null;function initA(){if(!aC){aC=new AC();mG=aC.createGain();mG.gain.value=.25;dD=aC.createDelay(2);dD.delayTime.value=.375;const f=aC.createGain();f.gain.value=.35;const dF=aC.createBiquadFilter();dF.type='lowpass';dF.frequency.value=2800;dD.connect(f);f.connect(dF);dF.connect(dD);dF.connect(mG);muG=aC.createGain();muG.gain.value=.08;muG.connect(mG);mG.connect(aC.destination);if(iM){sDNB();cVC();sGE()}}}function cVC(){const bS=aC.sampleRate*.5;const b=aC.createBuffer(1,bS,aC.sampleRate);const d=b.getChannelData(0);for(let i=0;i<bS;i++)d[i]=(Math.random()-.5)*.015;vC=aC.createBufferSource();vC.buffer=b;vC.loop=true;const cG=aC.createGain();cG.gain.value=.003;const cF=aC.createBiquadFilter();cF.type='highpass';cF.frequency.value=3000;vC.connect(cF);cF.connect(cG);cG.connect(mG);vC.start()}function sDNB(){const bpm=174;const bD=60/bpm;let bC=0;const sD=()=>{const n=aC.currentTime;if(bC%4===0||bC%4===2)sK(n+.1);if(bC%4===1||bC%4===3)sSn(n+.1);if(Math.random()>.3)sH(n+.1,Math.random()>.5);if(bC%2===0&&Math.random()>.2)sB(n+.1,bC);bC++};dL=setInterval(sD,bD*250)}function sK(t){const o=aC.createOscillator();const g=aC.createGain();o.type='sine';o.frequency.setValueAtTime(150,t);o.frequency.exponentialRampToValueAtTime(40,t+.5);g.gain.setValueAtTime(.4,t);g.gain.exponentialRampToValueAtTime(.01,t+.5);o.connect(g);g.connect(muG);o.start(t);o.stop(t+.5)}function sSn(t){const bS=aC.sampleRate*.2;const b=aC.createBuffer(1,bS,aC.sampleRate);const d=b.getChannelData(0);for(let i=0;i<bS;i++)d[i]=Math.random()*2-1;const n=aC.createBufferSource();n.buffer=b;const f=aC.createBiquadFilter();f.type='highpass';f.frequency.value=1000;const g=aC.createGain();g.gain.setValueAtTime(.15,t);g.gain.exponentialRampToValueAtTime(.01,t+.2);n.connect(f);f.connect(g);g.connect(muG);n.start(t);n.stop(t+.2)}function sH(t,o){const bS=aC.sampleRate*(o?.3:.05);const b=aC.createBuffer(1,bS,aC.sampleRate);const d=b.getChannelData(0);for(let i=0;i<bS;i++)d[i]=Math.random()*2-1;const n=aC.createBufferSource();n.buffer=b;const f=aC.createBiquadFilter();f.type='highpass';f.frequency.value=7000;const g=aC.createGain();g.gain.setValueAtTime(o?.06:.04,t);g.gain.exponentialRampToValueAtTime(.01,t+bS/aC.sampleRate);n.connect(f);f.connect(g);g.connect(muG);n.start(t);n.stop(t+bS/aC.sampleRate)}function sB(t,bC){const fs=[55,65,73,82];const fr=fs[bC%4];const o=aC.createOscillator();const g=aC.createGain();const f=aC.createBiquadFilter();o.type='sawtooth';o.frequency.value=fr;f.type='lowpass';f.frequency.setValueAtTime(800,t);f.frequency.exponentialRampToValueAtTime(200,t+.3);f.Q.value=8;g.gain.setValueAtTime(.12,t);g.gain.exponentialRampToValueAtTime(.01,t+.5);o.connect(f);f.connect(g);g.connect(muG);g.connect(dD);o.start(t);o.stop(t+.5)}function sGE(){gI=setInterval(()=>{if(!iM||Math.random()>.15)return;const n=aC.currentTime;const pO=aC.createOscillator();const pG=aC.createGain();pO.frequency.setValueAtTime(Math.random()*3000+500,n);pG.gain.setValueAtTime(.08,n);pG.gain.exponentialRampToValueAtTime(.01,n+.1);pO.connect(pG);pG.connect(mG);pO.start(n);pO.stop(n+.1)},3000)}document.getElementById('audioToggle').addEventListener('click',()=>{iS=!iS;iM=!iM;document.getElementById('audioIcon').textContent=iS?'üîä':'üîá';if(iS){if(!aC)initA();else{if(!dL)sDNB();if(!gI)sGE()}}else{if(dL){clearInterval(dL);dL=null}if(gI){clearInterval(gI);gI=null}if(vC){vC.stop();vC=null}}});document.addEventListener('click',()=>{if(!aC)initA()},{once:true});`;document.head.appendChild(s)};

        // Ambient effects (ultra-lite)
        const tA=()=>{const a=document.createElement('div');a.className='aurora';a.id='aurora';document.body.appendChild(a);a.classList.add('active');setTimeout(()=>a.classList.remove('active'),15000);setTimeout(tA,45000+Math.random()*15000)};const cAO=()=>{const o=document.createElement('div');o.className='ambient-orb';const s=200+Math.random()*300;const x=Math.random()*100;const y=Math.random()*100;const cs=['var(--neon-cyan)','var(--neon-magenta)','var(--plasma-pink)'];const c=cs[Math.floor(Math.random()*cs.length)];o.style.cssText=`width:${s}px;height:${s}px;left:${x}%;top:${y}%;background:radial-gradient(circle,${c},transparent)`;document.body.appendChild(o);setTimeout(()=>o.classList.add('active'),100);const d=20000+Math.random()*10000;o.animate([{transform:'translate(0,0) scale(1)'},{transform:`translate(${(Math.random()-.5)*200}px,${(Math.random()-.5)*200}px) scale(1.2)`}],{duration:d,easing:'ease-in-out'});setTimeout(()=>{o.classList.remove('active');setTimeout(()=>o.remove(),2000)},d);setTimeout(cAO,30000+Math.random()*15000)};const cM=()=>{const m=document.createElement('div');m.className='meteor';m.style.cssText=`left:${Math.random()*100}%;top:-10%`;document.body.appendChild(m);setTimeout(()=>m.remove(),2000)};const tMS=()=>{const mc=3+Math.floor(Math.random()*5);for(let i=0;i<mc;i++)setTimeout(()=>cM(),i*300);setTimeout(tMS,60000+Math.random()*30000)};

        // Intersection Observer for lazy loading
        const io=new IntersectionObserver(e=>{e.forEach(en=>{if(en.isIntersecting){if(en.target.id==='stats'){lD();io.unobserve(en.target)}else if(en.target.id==='audioToggle'){iA();io.unobserve(en.target)}}})},{rootMargin:'50px'});io.observe(document.getElementById('stats'));io.observe(document.getElementById('audioToggle'));

        // Ripple effect on click
        const createRipple = (x, y) => {
            const ripple = document.createElement('div');
            ripple.className = 'pulse-ring';
            ripple.style.cssText = `left:${x-25}px;top:${y-25}px`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 3000);
        };

        document.addEventListener('click', e => {
            if(e.target.tagName !== 'A' && e.target.tagName !== 'BUTTON') {
                createRipple(e.clientX, e.clientY);
            }
        });

        // Parallax scroll effect
        let scrollY = 0;
        const parallaxElements = [];

        const initParallax = () => {
            document.querySelectorAll('.avatar, .stat-card, .repo-card').forEach((el, i) => {
                parallaxElements.push({
                    el,
                    speed: 0.3 + (i % 3) * 0.1,
                    initialY: el.offsetTop
                });
            });
        };

        setTimeout(initParallax, 2000);

        window.addEventListener('scroll', () => {
            scrollY = window.pageYOffset;

            for(const item of parallaxElements) {
                const rect = item.el.getBoundingClientRect();
                if(rect.top < window.innerHeight && rect.bottom > 0) {
                    const offset = (scrollY - item.initialY) * item.speed;
                    item.el.style.transform = `translateY(${offset * 0.5}px)`;
                }
            }
        }, {passive: true});

        // Scroll progress indicator
        const createScrollIndicator = () => {
            const indicator = document.createElement('div');
            indicator.style.cssText = 'position:fixed;top:0;left:0;height:3px;background:linear-gradient(90deg,var(--neon-cyan),var(--neon-magenta));z-index:10000;transition:width .1s;width:0';
            document.body.appendChild(indicator);

            window.addEventListener('scroll', () => {
                const scrollPercent = (window.pageYOffset / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
                indicator.style.width = scrollPercent + '%';
            }, {passive: true});
        };

        setTimeout(createScrollIndicator, 1000);

        // Start ambient (delayed)
        setTimeout(()=>{setTimeout(tA,20000);setTimeout(cAO,15000);setTimeout(tMS,30000)},2000);

        // Smooth scroll
        document.querySelectorAll('a[href^="#"]').forEach(a=>a.addEventListener('click',function(e){e.preventDefault();const t=document.querySelector(this.getAttribute('href'));if(t)t.scrollIntoView({behavior:'smooth',block:'start'})}));
    </script>

    <!-- Advanced Effects System (Lazy Loaded) -->
    <script>
        // Advanced effects initialization (ultra-optimized with lazy loading)
        let advancedFXLoaded = false;
        let webglActive = false;
        let audioVizActive = false;
        let particlesActive = false;
        let gesturesActive = false;

        // Lazy load advanced effects after initial render
        const initAdvancedEffects = () => {
            if(advancedFXLoaded) return;
            advancedFXLoaded = true;

            // WebGL Shader System (Cyberpunk Effects)
            const initWebGL = () => {
                const canvas = document.getElementById('webglCanvas');
                const gl = canvas.getContext('webgl', {alpha: true, antialias: false, powerPreference: 'high-performance'});
                if(!gl) return;

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Vertex shader
                const vsSource = `
                    attribute vec4 aPosition;
                    void main() { gl_Position = aPosition; }
                `;

                // Fragment shader (Cyberpunk distortion + chromatic aberration)
                const fsSource = `
                    precision mediump float;
                    uniform vec2 uResolution;
                    uniform float uTime;
                    uniform vec2 uMouse;

                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }

                    float noise(vec2 st) {
                        vec2 i = floor(st);
                        vec2 f = fract(st);
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }

                    void main() {
                        vec2 st = gl_FragCoord.xy / uResolution.xy;
                        vec2 mouseInfluence = (uMouse / uResolution) - 0.5;

                        // Flow field distortion
                        float n = noise(st * 3.0 + uTime * 0.1);
                        st += n * 0.02 * sin(uTime * 0.5);

                        // Mouse interaction
                        float dist = length(st - uMouse / uResolution);
                        st += mouseInfluence * 0.05 * (1.0 - dist);

                        // Scanlines
                        float scanline = sin(st.y * 800.0 + uTime * 2.0) * 0.04;

                        // Vignette
                        float vignette = smoothstep(0.8, 0.2, length(st - 0.5));

                        // Grid pattern
                        vec2 grid = fract(st * 20.0);
                        float gridLine = step(0.95, max(grid.x, grid.y)) * 0.1;

                        // Cyberpunk colors
                        vec3 cyan = vec3(0.0, 1.0, 1.0);
                        vec3 magenta = vec3(1.0, 0.0, 1.0);
                        vec3 color = mix(cyan, magenta, st.x + sin(uTime * 0.2) * 0.5);
                        color *= (0.05 + n * 0.1 + gridLine + scanline);
                        color *= vignette;

                        gl_FragColor = vec4(color, 0.3);
                    }
                `;

                const compileShader = (src, type) => {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, src);
                    gl.compileShader(shader);
                    return shader;
                };

                const vs = compileShader(vsSource, gl.VERTEX_SHADER);
                const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                gl.useProgram(program);

                const positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const posLoc = gl.getAttribLocation(program, 'aPosition');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                const uResolution = gl.getUniformLocation(program, 'uResolution');
                const uTime = gl.getUniformLocation(program, 'uTime');
                const uMouse = gl.getUniformLocation(program, 'uMouse');

                let mouseX = window.innerWidth / 2;
                let mouseY = window.innerHeight / 2;
                document.addEventListener('mousemove', e => {
                    mouseX = e.clientX;
                    mouseY = canvas.height - e.clientY;
                }, {passive: true});

                canvas.style.opacity = '1';
                webglActive = true;

                let lastTime = 0;
                const render = (time) => {
                    if(!webglActive) return;
                    time *= 0.001;

                    // Throttle to 30fps for performance
                    if(time - lastTime < 0.033) {
                        requestAnimationFrame(render);
                        return;
                    }
                    lastTime = time;

                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.uniform2f(uResolution, canvas.width, canvas.height);
                    gl.uniform1f(uTime, time);
                    gl.uniform2f(uMouse, mouseX, mouseY);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    requestAnimationFrame(render);
                };
                requestAnimationFrame(render);

                // Resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }, 250);
                }, {passive: true});
            };

            // Advanced Particle System with Physics
            const initParticles = () => {
                const canvas = document.getElementById('particleCanvas');
                const ctx = canvas.getContext('2d', {alpha: true, desynchronized: true});
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Object pool for particles
                class ParticlePool {
                    constructor(size) {
                        this.pool = [];
                        this.active = [];
                        for(let i = 0; i < size; i++) {
                            this.pool.push({
                                x: 0, y: 0, vx: 0, vy: 0,
                                life: 0, maxLife: 0,
                                size: 0, color: '', alpha: 1
                            });
                        }
                    }
                    get() {
                        const p = this.pool.pop() || {x:0,y:0,vx:0,vy:0,life:0,maxLife:0,size:0,color:'',alpha:1};
                        this.active.push(p);
                        return p;
                    }
                    release(p) {
                        const idx = this.active.indexOf(p);
                        if(idx > -1) {
                            this.active.splice(idx, 1);
                            this.pool.push(p);
                        }
                    }
                }

                const pool = new ParticlePool(500);
                const colors = ['#00ffff', '#ff00ff', '#ffff00', '#0066ff'];

                // Flow field
                const flowField = [];
                const cols = 30;
                const rows = 30;
                for(let i = 0; i < cols * rows; i++) {
                    flowField[i] = Math.random() * Math.PI * 2;
                }

                let mouseX = canvas.width / 2;
                let mouseY = canvas.height / 2;
                let mouseDown = false;

                document.addEventListener('mousemove', e => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }, {passive: true});

                document.addEventListener('mousedown', () => mouseDown = true);
                document.addEventListener('mouseup', () => mouseDown = false);

                const spawnParticle = (x, y, color) => {
                    const p = pool.get();
                    p.x = x;
                    p.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = 60 + Math.random() * 60;
                    p.size = 2 + Math.random() * 4;
                    p.color = color;
                    p.alpha = 1;
                };

                let spawnCounter = 0;
                canvas.style.opacity = '1';
                particlesActive = true;

                const animate = () => {
                    if(!particlesActive) return;

                    ctx.fillStyle = 'rgba(10, 10, 15, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Spawn particles
                    if(mouseDown && spawnCounter++ % 2 === 0) {
                        spawnParticle(mouseX, mouseY, colors[Math.floor(Math.random() * colors.length)]);
                    }

                    // Random spawn
                    if(Math.random() > 0.97) {
                        spawnParticle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            colors[Math.floor(Math.random() * colors.length)]
                        );
                    }

                    // Update and draw
                    for(let i = pool.active.length - 1; i >= 0; i--) {
                        const p = pool.active[i];

                        // Flow field influence
                        const col = Math.floor((p.x / canvas.width) * cols);
                        const row = Math.floor((p.y / canvas.height) * rows);
                        const index = col + row * cols;
                        if(flowField[index] !== undefined) {
                            const angle = flowField[index];
                            p.vx += Math.cos(angle) * 0.1;
                            p.vy += Math.sin(angle) * 0.1;
                        }

                        // Mouse attraction
                        const dx = mouseX - p.x;
                        const dy = mouseY - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if(dist < 200) {
                            const force = (200 - dist) / 200;
                            p.vx += (dx / dist) * force * 0.5;
                            p.vy += (dy / dist) * force * 0.5;
                        }

                        // Velocity damping
                        p.vx *= 0.98;
                        p.vy *= 0.98;

                        p.x += p.vx;
                        p.y += p.vy;
                        p.life++;

                        // Fade out
                        p.alpha = 1 - (p.life / p.maxLife);

                        // Draw
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.alpha * 0.6;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Release dead particles
                        if(p.life >= p.maxLife || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                            pool.release(p);
                        }
                    }

                    ctx.globalAlpha = 1;
                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);

                // Update flow field
                setInterval(() => {
                    for(let i = 0; i < flowField.length; i++) {
                        flowField[i] += (Math.random() - 0.5) * 0.5;
                    }
                }, 100);

                // Resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }, 250);
                }, {passive: true});
            };

            // Audio-Reactive Visualizer (Enhanced)
            const initAudioViz = () => {
                const canvas = document.getElementById('audioViz');
                const ctx = canvas.getContext('2d', {alpha: true, desynchronized: true});
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Wait for audio context to be available
                const checkAudio = setInterval(() => {
                    if(window.aC && window.aC.state === 'running') {
                        clearInterval(checkAudio);
                        startViz();
                    }
                }, 100);

                const startViz = () => {
                    const analyser = window.aC.createAnalyser();
                    analyser.fftSize = 512;
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    // Connect to master gain
                    if(window.mG) {
                        window.mG.connect(analyser);
                    }

                    canvas.style.opacity = '1';
                    audioVizActive = true;

                    const barCount = 64;
                    const bars = new Array(barCount).fill(0);
                    const barTargets = new Array(barCount).fill(0);

                    let rotation = 0;
                    const animate = () => {
                        if(!audioVizActive) return;

                        analyser.getByteFrequencyData(dataArray);

                        ctx.fillStyle = 'rgba(10, 10, 15, 0.2)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const radius = Math.min(canvas.width, canvas.height) / 4;

                        rotation += 0.005;

                        // Circular visualizer
                        for(let i = 0; i < barCount; i++) {
                            const index = Math.floor((i / barCount) * bufferLength);
                            barTargets[i] = dataArray[index] / 255;
                            bars[i] += (barTargets[i] - bars[i]) * 0.3; // Smooth

                            const angle = (i / barCount) * Math.PI * 2 + rotation;
                            const x1 = centerX + Math.cos(angle) * radius;
                            const y1 = centerY + Math.sin(angle) * radius;
                            const barHeight = bars[i] * 150;
                            const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                            const y2 = centerY + Math.sin(angle) * (radius + barHeight);

                            // Color based on frequency
                            const hue = (i / barCount) * 360;
                            ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${bars[i] * 0.8})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }

                        // Center circle
                        const avgVolume = bars.reduce((a, b) => a + b) / barCount;
                        ctx.fillStyle = `rgba(0, 255, 255, ${avgVolume * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius * 0.8 + avgVolume * 30, 0, Math.PI * 2);
                        ctx.fill();

                        requestAnimationFrame(animate);
                    };
                    requestAnimationFrame(animate);
                };

                // Resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }, 250);
                }, {passive: true});
            };

            // Gesture Recognition System
            const initGestures = () => {
                const canvas = document.getElementById('gestureCanvas');
                const ctx = canvas.getContext('2d', {alpha: true});
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                let isDrawing = false;
                let points = [];
                let trails = [];

                const addPoint = (x, y) => {
                    points.push({x, y, time: Date.now()});
                    if(points.length > 50) points.shift();
                };

                canvas.addEventListener('mousedown', e => {
                    isDrawing = true;
                    canvas.style.opacity = '0.3';
                    points = [];
                    addPoint(e.clientX, e.clientY);
                });

                canvas.addEventListener('mousemove', e => {
                    if(!isDrawing) return;
                    addPoint(e.clientX, e.clientY);
                });

                canvas.addEventListener('mouseup', () => {
                    if(!isDrawing) return;
                    isDrawing = false;

                    // Analyze gesture
                    if(points.length > 10) {
                        const totalDist = points.reduce((sum, p, i) => {
                            if(i === 0) return 0;
                            const dx = p.x - points[i-1].x;
                            const dy = p.y - points[i-1].y;
                            return sum + Math.sqrt(dx*dx + dy*dy);
                        }, 0);

                        const directDist = Math.sqrt(
                            Math.pow(points[points.length-1].x - points[0].x, 2) +
                            Math.pow(points[points.length-1].y - points[0].y, 2)
                        );

                        const straightness = directDist / totalDist;

                        // Trigger effects based on gesture
                        if(straightness > 0.8) {
                            // Straight line - spawn particles along path
                            for(let i = 0; i < points.length; i += 3) {
                                trails.push({
                                    x: points[i].x,
                                    y: points[i].y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    life: 60,
                                    size: 3 + Math.random() * 5
                                });
                            }
                        } else {
                            // Curved gesture - create explosion
                            const cx = points.reduce((s, p) => s + p.x, 0) / points.length;
                            const cy = points.reduce((s, p) => s + p.y, 0) / points.length;
                            for(let i = 0; i < 30; i++) {
                                const angle = (i / 30) * Math.PI * 2;
                                trails.push({
                                    x: cx,
                                    y: cy,
                                    vx: Math.cos(angle) * (5 + Math.random() * 5),
                                    vy: Math.sin(angle) * (5 + Math.random() * 5),
                                    life: 40 + Math.random() * 40,
                                    size: 2 + Math.random() * 4
                                });
                            }
                        }
                    }

                    points = [];
                    setTimeout(() => canvas.style.opacity = '0', 500);
                });

                // Touch support
                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    isDrawing = true;
                    canvas.style.opacity = '0.3';
                    points = [];
                    addPoint(touch.clientX, touch.clientY);
                }, {passive: false});

                canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if(!isDrawing) return;
                    const touch = e.touches[0];
                    addPoint(touch.clientX, touch.clientY);
                }, {passive: false});

                canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    canvas.dispatchEvent(new Event('mouseup'));
                }, {passive: false});

                gesturesActive = true;

                // Animate trails
                const animate = () => {
                    if(!gesturesActive) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Draw current drawing
                    if(points.length > 1) {
                        ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        for(let i = 1; i < points.length; i++) {
                            ctx.lineTo(points[i].x, points[i].y);
                        }
                        ctx.stroke();
                    }

                    // Draw and update trails
                    for(let i = trails.length - 1; i >= 0; i--) {
                        const t = trails[i];
                        t.x += t.vx;
                        t.y += t.vy;
                        t.vy += 0.3; // Gravity
                        t.vx *= 0.98;
                        t.vy *= 0.98;
                        t.life--;

                        const alpha = t.life / 60;
                        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
                        ctx.fill();

                        if(t.life <= 0) trails.splice(i, 1);
                    }

                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);

                // Resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }, 250);
                }, {passive: true});
            };

            // Initialize all systems with staggered loading based on device capability
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isLowPerf = navigator.hardwareConcurrency < 4 || isMobile;

            // Adjust effects based on device
            if(!isLowPerf) {
                setTimeout(() => initWebGL(), 1000);
                setTimeout(() => initParticles(), 2000);
                setTimeout(() => initAudioViz(), 3000);
                setTimeout(() => initGestures(), 4000);
            } else {
                // Mobile/low-perf: only essential effects
                setTimeout(() => initParticles(), 2000);
                setTimeout(() => initGestures(), 3000);
            }
        };

        // Trigger advanced effects on user interaction
        let interactionDetected = false;
        const triggerAdvanced = () => {
            if(interactionDetected) return;
            interactionDetected = true;
            initAdvancedEffects();
        };

        // Multiple triggers
        document.addEventListener('click', triggerAdvanced, {once: true});
        document.addEventListener('scroll', triggerAdvanced, {once: true, passive: true});
        document.addEventListener('touchstart', triggerAdvanced, {once: true, passive: true});

        // Auto-trigger after delay
        setTimeout(triggerAdvanced, 5000);

        // Performance monitoring
        let frameCount = 0;
        let lastFpsTime = performance.now();
        setInterval(() => {
            const now = performance.now();
            const fps = Math.round(frameCount / ((now - lastFpsTime) / 1000));
            frameCount = 0;
            lastFpsTime = now;

            // Auto-disable heavy effects if FPS drops below 30
            if(fps < 30) {
                if(webglActive) {
                    webglActive = false;
                    document.getElementById('webglCanvas').style.opacity = '0';
                }
            }
        }, 2000);

        requestAnimationFrame(function countFPS() {
            frameCount++;
            requestAnimationFrame(countFPS);
        });
    </script>
</body>
</html>
